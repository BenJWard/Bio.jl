---
part: Contributing
title: Implementing parsers
order: 1000
...

This document is an overview of how parsers work in Bio.jl, including how to
implement new parsers.

The parsing framework in Bio.jl is unique amongst bioinformatics libraries.
Rather than hand-written parsers, we use grammar specifications that are
compiled into parser code using a tool called
[ragel](http://www.colm.net/open-source/ragel/).

These parsers can generally be as fast or faster than hand-written parsers while
being much more explicit about the syntax of the format they parse. Ragel parses
only regular languages, which means not everything can be written as a ragel
parser, yet most formats can be, including many binary formats.

# Installing ragel

Currently Julia is not an officially supported language in ragel, but is
maintained in a BioJulia fork of the project
[here](https://github.com/BioJulia/ragel). This will change when ragel 7.0 is
released, but for the time being we have to maintain our own Julia backend.

Installing ragel is relatively straightforward. First you must install version
0.12 of colm,
which is the language that the generator backends are implemented in.

```sh
wget http://www.colm.net/files/colm/colm-0.12.0.tar.gz
tar xzf colm-0.12.0.tar.gz
cd colm-0.12.0
./configure
make install
```

Then ragel can be installed.


```sh
git clone https://github.com/BioJulia/ragel.git
cd ragel
./autogen.sh
./configure --disable-manual
make install
```

# Running ragel

Ragel takes as input a `.rl` file and generates regular Julia source code in a
`.jl` file. Ragel source files are a mixture of Julia code and ragel's machine
specification language.

In Bio.jl we use a makefile to generate parsers. The following make recipe is
used to generate ragel parsers, which simply runs ragel, prepending a warning to
the generated file.

```make
%.jl: %.rl
    ragel -U -G2 $< -o $@.tmp
    echo "# WARNING: This file was generated from $< using ragel. Do not edit!" > $@
    sed 's/[[:space:]]*$$//g' $@.tmp >> $@
    rm $@.tmp
```

It runs ragel with the `-U` option which sets Julia as the host language, and
`-G2` which intstructs it to generate a fast goto-based parser. Ragel can
generate other types of parsers generally trading off speed for conciceness:
`-G1` will generate a less agressively unrolled goto based parser, while `-T0`,
`-T1`, `-F0`, `-F1` generate table-based parsers, which are generally less
efficient, but also produce far less code. All of these should otherwise
function the same. Using `-G2` parsers will produce the fastest code, but also
the code with the highest upfront compilation cost.

An easy mistake to make when working on a parser is to make a change to the
`.rl` source file, but forget to regenerate the `.jl` file. One easy way to
avoid this is to use the [entr](http://entrproject.org/) tool, which watches
some files and runs a command when one changes. Running the following command in
directory of some `.rl` files and a corresponding makefile will automatically
keep the `.jl` files up to date until it's killed.

```sh
ls *.rl | entr make
```

# Writing parsers

Throughout this guide we will demonstrate how to add new parsers by implementing
a parser for a very simplistic format: a 3-field BED file, in which each line
contains a sequence name followed by a start and end position. There is already
a more full feature BED parser in Bio, so this is purely pedagogical, but a
useful starting point.

A BED3 file might look like this.

```
chr9    68288114        68330909
chr9    68331023        68424451
chr9    68331037        68419993
chr9    68331055        68426908
chr9    68331083        68390919
chr9    68331113        68424451
```

## Writing a machine specification

Though we are using a newer version of ragel, the specification language has not
significantly changed, so the the [manual for
ragel-6.9](http://www.colm.net/files/ragel/ragel-guide-6.9.pdf) is the best
source to learn the basics of how to write ragel parsers. It's also useful to
have a basic understanding of finite state machines (FSMs). The main feature of
ragel, compared to other parser generator tools for regular languages, is that
it allows arbitrary code to be executed on transitions in the FSM.

Let's start with a basic specification BED3 in ragel.

```ragel
%%{
    machine bed3;

    seqname = [ -~]*;
    start   = digit+;
    stop    = digit+;
    bed3_entry = seqname '\t' start '\t' stop '\n';
    main := bed3_entry*;
}%%
```

In `.rl` files, ragel annotations and code are marked with `%%` to separate it
from the host language (Julia, in our case). The first line of the specification
gives a name to the FSM, the remaining lines define the language that it
accepts. Each line of the specification assigns a name to some part of the
overall machine, which is itself called `main`. We could write the whole thing
as

```ragel
%%{
    machine bed3;
    main := ([ -~]* '\t' digit+ '\t' digit+ '\t')*;
}%%
```

but assigning names to parts of the machine makes things clearer and will help
us later when we start defining actions for the parser.

The specification language will look familiar to those who have used parser
generators or regular expressions in the past.  Similar to most regular
expression grammars `+` indicates "one or more of", `*` "any number of", and `[
-~]` a range of accepted characters. In this case space through `~`, which is
all printable ASCII characters and space.

## Actions

A distinguishing feature of ragel is the ability to execute arbitrary code on
state machine transitions (see Chapter 3 of the ragel manual). Ragel with
generate code to parse the input, but it's up to us to decide what to do when
parts of the language are matched. Here are some basic actions that print
annoying messages whenever the machine starts or finishes matching a sequence
name.

```ragel
%%{
    action seqname_begin {
        println("started matching seqname")
    }

    action seqname_finish {
        println("finished matching seqname")
    }

    seqname = [ -~]* >seqname_begin %seqname_finish;
}%%
```

Actions are named blocks of Julia code which get copied into the appropriate
place by ragel. There are a number of annotations that can used to decide when
they are executed, but typically just `>` and `%` are needed. The former causes
an action to be executed when part of the state machine is transitioned into,
and the latter when part is transitioned out of. Together they can be used to
process input fields.


## Parsing in parts

Before we go further, we need to discuss some practical considerations. Parsing
data contained in a string in one shot is made quite simple with ragel (most of
the examples you'll see in the manual follow this pattern). However with many
formats we don't have the luxury of reading all the input into memory before
parsing, since the input is simply too large. The BED3 files we wish to parse
may represent short read alignments or other high-throughput data, so they could
consist of hundreds of millions of lines. Instead we have to work from buffered
input streams. This complicates parsing, but most of this complexity is hid in
the `Bio.Ragel` module, which contains macros that generate code to handle
buffer refills, and other gory details.


## Defining a result type

Parsers in Bio.jl work on mutable entry types, which allows us to perform
very-efficient parsing by reusing previously allocated space. Defining a BED3
entry type is straightforward except for one catch: strings in Julia are
immutable which prevents us from overwriting them when a new entry is read.

To overcome this restriction string fields in parsed types uses a special
mutable string type called `StringField`. It works similarly to `UTF8String` in
base but has no immutability guarentees.

```julia
using Bio.StringFields

type BED3Entry
    seqname::StringField
    start::Int64
    stop::Int64
end
```

This type needs to have two functions. A constructor with no parameters to
allocate an empty entry, and a `copy` function.

```julia
function BED3Entry()
    return BED3Entry(StringField(), 1, 0)
end


function copy(entry::BED3Entry)
    return BED3Entry(copy(entry.seqname), entry.start, entry.stop)
end
```

## Capturing input with `@anchor!`

To efficiently parse on buffered stream, `Bio.Ragel` has some tricks to avoid
making unecessary allocations or copies. These revolve around "anchoring" the
start of regions in the input that need to be processed using the `Ragel.@anchor!`
macro. Using `@anchor!` saves the current position and informs the input stream
not to evict that part of the input from the input buffer. If the buffer needs
to be refilled, it is shifted over but saved.

Let's see how that works by defining a slightly more meaningful action
`seqname`.

```ragel
%%{
    action anchor {
        Ragel.@anchor
    }

    action seqname {
        Ragel.@copy_from_anchor!(output.seqname)
    }

    seqname = [ -~]* >anchor %seqname;
}%%
```

When we enter FSM state associated with `seqname`, the `anchor` action gets
executed, internally marking the input stream and guaranteeing that it will stay
in the buffer. We then use another macro `Ragel.@acopy_from_anchor!` which
extracts a string directly from the input, replacing the contents of a
`StringField`, and unsets the anchor, so that the data is no longer preserved.

There are some other handy macros for efficiently processing marked data:
`Ragel.@int64_from_anchor!` will parse an integer from a marked region without
making an intermediate copy, `Ragel.@upanchor!` will unset the anchor and return
it's position in the input buffer. The matched region of the input buffer can
extracted as an `UInt8` vector like.

```ragel
state.stream.buffer[(Ragel.@upanchor!):p]
```

Using `@anchor!` has some limitations. Because it causes data to preserved and
shifted on buffer refills, it can be slow if the data that it needs to preserved
is very large. It efficient assuming the buffer is significantly larger than the
fields being caputured so that shifts are rare. If a very long field needs to be
captured, another mechanism should be used, like copying the input one character
at a time to a buffer.

With this understood, we can complete our machine definition

```ragel
%%{
    machine bed3;

    action anchor {
        Ragel.@anchor!
    }

    action finish_match {
        # calling anchor is necessary here because fbreak will skip the entry
        # action for the next state (seqname, in this case)
        Ragel.@anchor!
        yield = true;
        fbreak;
    }

    action seqname {
        Ragel.@copy_from_anchor!(output.seqname)
    }

    action start {
        # convert from 0-based to 1-based
        output.start = 1 + Ragel.@int64_from_anchor!
    }

    action stop {
        output.stop = Ragel.@int64_from_anchor!
    }

    seqname = [ -~]*   >anchor   %seqname;
    start   = digit+   >anchor   %start;
    stop    = digit+   >anchor   %stop;
    bed3_entry = seqname '\t' start '\t' stop '\n';
    main := (bed3_entry %finish_match)*;
}%%
```

## Supporting code

Now that we have a machine definition and a entry type, we must define a parser
type and write a few supportinf functions.

First, code generated by ragel needs to reference some special constants
representing parser states. To define these we use the `write data` ragel
directive.

```ragel
%% write data;
```

Since most formats are read entry-by-entry, we need a type to keep track of the
parser state between calls. This type must have a field called `state` of type
`Ragel.State`. It can contain any other supporting data useful for parsing, such
as intermediate results.

```julia
using Bio: AbstractParser
import Bio.Ragel

type BED3Parser <: AbstractParser
    state::Ragel.State
end
```

There are three functions we must define for the parser to be functional:
`eltype`, `open`, and `read!`. The first two have obvious definitions.

```julia
# return the type that BED3Parser reads to
function eltype(::Type{BED3Parser})
    return BED3Entry
end
```

Secondly, we need an `open` function. To do this, we define an empty file format
type used to indicate BED3.

```
immutable BED3 <: FileFormat end

function open(input::BufferedInputStream, ::Type{BED3})
    return BED3Parser(input)
end
```

`open` needs only be defined over a `BufferedInputStream` to work for file names
and byte vectors automatically.

Lastly the `read!` function, which to simplify we generate using a macro:
`Ragel.@generate_read_function`. This takes four parameters: a string giving the
ragel machine name, the parser type, the entry type, and finally ragel generated
state machine code. Putting this together, defining our `read!` function looks
like:

```{.julia execute="false"}
Ragel.@generate_read_fuction("bed3", BED3Parser, BED3Entry,
    begin
        %% write exec;
    end)
```

Our parser is ready to use now.

# Optimizing and debugging parsers

A major complication is debugging or optimizing ragel generated parsers is that
with current versions of Julia, line numbers in stack traces and profiler output
will be unreliable. Until this situation improves, profiling parsers using
`@profile` is of limited use. A more fruitful way to improve the speed of
parsers is to work from the state transition diagram.

These diagrams can often illucidate unecessary work being performed by the
parser, or incorrectly specified grammars. Tracing through this diagram
step-by-step, and making sure it agrees with your intention is an important
sanity check when implementing a moderately complex parser.

Unfortunately, there are some issues with generating these state diagrams
with our development version of ragel. To produce these you should install the
[ragel 6.9](http://www.colm.net/files/ragel/ragel-6.9.tar.gz) in a separate
directory. You will also need [graphviz](http://www.graphviz.org/).

The makefile rules we use to generate diagrams are

```make
%.dot: %.rl
    ~/src/ragel-6.9/ragel/ragel -p -V $< > $@

%.svg: %.dot
    dot -Tsvg < $< > $@
```

This assumes ragel 6.9 is compiled in `~/src/ragel-6.9/`. It first runs ragel to
generate `.dot` graphviz specification file, then runs the graphviz `dot`
program to generate an svg file.

